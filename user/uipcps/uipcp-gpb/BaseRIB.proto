syntax = "proto2";
package gpb;
option optimize_for = LITE_RUNTIME;

message objectValue_t {  // value of an object
  optional int32 intval = 1;
  optional sint32 sintval = 2;
  optional int64 int64val = 3;
  optional sint64 sint64val = 4;
  optional string strval = 5;
  optional bytes byteval = 6;  // arbitrary structure or message
  optional fixed32 floatval = 7;
  optional fixed64 doubleval = 8;
}

message nameValuePair_t {  // A name-value pair
  optional string name = 1;
  optional objectValue_t value = 2;
}

message property_t {  // carries the information of a name/value pair
  required string name = 1;
  required string value = 2;
}

message a_data_t {
  optional int32 sourceAddress = 1;
  optional int32 destAddress = 2;
  optional bytes cdapMessage = 3;
}

message AddrAllocRequest {
  required uint64 requestor = 1;
  required uint64 address = 2;
}

message AddrAllocEntries {
  repeated AddrAllocRequest entries = 1;
}

// carries the naming information of an application process
message applicationProcessNamingInfo_t {
  required string applicationProcessName = 1;
  optional string applicationProcessInstance = 2;
  optional string applicationEntityName = 3;
  optional string applicationEntityInstance = 4;
}

// the window-based flow control configuration of a connection
message dtcpWindowBasedFlowControlConfig_t {
  // Integer that the number PDUs that can be put on the ClosedWindowQueue
  // before something must be done
  optional uint64 maxclosedwindowqueuelength = 1;
  // initial sequence number to get right window edge
  optional uint64 initialcredit = 2;
  optional policyDescriptor_t rcvrflowcontrolpolicy =
      3;  // Invoked when a Transfer PDU is received to give the receiving PM an
          // opportunity to update the flow control allocations
  optional policyDescriptor_t txcontrolpolicy =
      4;  // This policy is used when there are conditions that warrant sending
          // fewer PDUs than allowed by the sliding window flow control, e.g.
          // the ECN bit is set.
}

message dtcpRateBasedFlowControlConfig_t {  // the rate-based flow control
                                            // configuration of a connection
  optional uint64 sendingrate = 1;  // the number of PDUs that may be sent in a
                                    // TimePeriod. Used with rate-based flow
                                    // control
  optional uint64 timeperiod =
      2;  // length of time in microseconds for pacing rate-based flow control
  optional policyDescriptor_t norateslowdownpolicy =
      3;  // used to momentarily lower the send rate below the rate allowed
  optional policyDescriptor_t nooverridedefaultpeakpolicy =
      4;  // Allows rate-based flow control to exceed its nominal rate
  optional policyDescriptor_t ratereductionpolicy =
      5;  // Allows an alternate action when using rate-based flow control and
          // the number of free buffers is getting low
}

message
    dtcpFlowControlConfig_t {  // the flow control configuration of a connection
  optional bool windowBased =
      1;  // indicates whether window-based flow control is in use
  optional dtcpWindowBasedFlowControlConfig_t windowBasedConfig =
      2;  // the window-based flow control configuration
  optional bool rateBased =
      3;  // indicates whether rate-based flow control is in use
  optional dtcpRateBasedFlowControlConfig_t rateBasedConfig =
      4;  // the rate-based flow control configuration
  optional uint64 sentbytesthreshold =
      5;  // The number of free bytes below which flow control should slow or
          // block the user from doing any more Writes
  optional uint64 sentbytespercentthreshold =
      6;  // The percent of free bytes below, which flow control should slow or
          // block the user from doing any more Writes
  optional uint64 sentbuffersthreshold =
      7;  // The number of free buffers below which flow control should slow or
          // block the user from doing any more Writes
  optional uint64 rcvbytesthreshold =
      8;  // The number of free bytes below which flow control does not move or
          // decreases the amount the Right Window Edge is moved
  optional uint64 rcvbytespercentthreshold =
      9;  // The number of free buffers at which flow control does not advance
          // or decreases the amount the Right Window Edge is moved.
  optional uint64 rcvbuffersthreshold =
      10;  // The percent of free buffers below which flow control should not
           // advance or decreases the amount the Right Window Edge is moved
  optional policyDescriptor_t closedwindowpolicy =
      11;  // Determine the action to be taken when the receiver has not
           // extended more credit to allow the sender to send more PDUs
  optional policyDescriptor_t flowcontroloverrunpolicy =
      12;  // Determines what action to take if the receiver receives PDUs but
           // the credit or rate has been exceeded
  optional policyDescriptor_t reconcileflowcontrolpolicy =
      13;  // Invoked when both Credit and Rate based flow control are in use
           // and they disagree on whether the PM can send or receive data
  optional policyDescriptor_t receivingflowcontrolpolicy =
      14;  // Allows some discretion in when to send a Flow Control PDU when
           // there is no Retransmission Control
}

message
    dtcpRtxControlConfig_t {  // the rtx control configuration of a connection
  optional uint32 maxtimetoretry =
      1;  // Maximum time trying to retransmit a PDU (R)
  optional uint32 datarxmsnmax = 2;  // the number of times the retransmission
                                     // of a PDU will be attempted before some
                                     // other action must be taken
  optional policyDescriptor_t rtxtimerexpirypolicy =
      3;  // Executed by the sender when a Retransmission Timer Expires
  optional policyDescriptor_t senderackpolicy =
      4;  // Executed by the sender and provides the Sender with some discretion
          // on when PDUs may be deleted from the ReTransmissionQ
  optional policyDescriptor_t recvingacklistpolicy = 5;  //
  optional policyDescriptor_t rcvrackpolicy =
      6;  // Executed by the receiver of the PDU and provides some discretion in
          // the action taken
  optional policyDescriptor_t sendingackpolicy =
      7;  // allows an alternate action when the A-Timer expires when DTCP is
          // present.
  optional policyDescriptor_t rcvrcontrolackpolicy =
      8;  // Allows an alternate action when a Control Ack PDU is received
  optional uint32 initialRtxTime =
      9;  // maximum time that a sender will wait before retransmitting the SDU
}

message dtcpConfig_t {  // configuration of DTCP for a connection
  optional bool flowControl =
      1;  // indicates if flow control is enabled in this connection
  optional dtcpFlowControlConfig_t flowControlConfig =
      2;  // the flow control configuration
  optional bool rtxControl =
      3;  // inidicates if rtx control is enabled in this connection
  optional dtcpRtxControlConfig_t rtxControlConfig =
      4;  // the rtx control configuration
  optional policyDescriptor_t lostcontrolpdupolicy =
      5;  // Determines what action to take when the PM detects that a control
          // PDU (Ack or Flow Control) may have been lost
  optional policyDescriptor_t rttestimatorpolicy =
      6;  // Executed by the sender to estimate the duration of the retx timer
}

message connectionPolicies_t {  // configuration of the policies and parameters
                                // of an EFCP connection
  optional bool dtcpPresent = 1;  // indicates if this connection is using DTCP
  optional dtcpConfig_t dtcpConfiguration =
      2;  // the DTCP Configuration for this connection
  optional policyDescriptor_t rcvrtimerinactivitypolicy =
      3;  // If no PDUs arrive in this time period, the receiver should expect a
          // DRF in the next Transfer PDU
  optional policyDescriptor_t sendertimerinactiviypolicy =
      4;  // This timer is used to detect long periods of no traffic, indicating
          // that a DRF should be sent
  optional policyDescriptor_t initialseqnumpolicy =
      5;  // allows some discretion in selecting the initial sequence number,
          // when DRF is going to be sent
  optional uint64 seqnumrolloverthreshold =
      6;  // the sequence number rollover threshold
  optional uint32 initialATimer =
      7;  // maximum time that a receiver will wait before sending an Ack
}

message directoryForwardingTableEntry_t {  // information about a
                                           // directoryforwardingtable entry
  required applicationProcessNamingInfo_t applicationName = 1;
  required string ipcp_name = 2;  // The name of the hosting IPCP
  optional uint64 timestamp = 3;  // TODO turn into a seqnum
}

message
    directoryForwardingTableEntrySet_t {  // carries information about
                                          // directoryforwardingtable entries
  repeated directoryForwardingTableEntry_t directoryForwardingTableEntry = 1;
}

message enrollmentInformation_t {  // carries information about a member that
                                   // requests enrollment to a DIF
  optional uint64 address = 1;
  repeated string supportingDifs = 2;
  optional bool startEarly = 3;
}

message connectionId_t {  // information to identify a connection
  optional uint32 qosId =
      1;  // identifies the QoS cube under which this flow is classified
  optional uint32 sourceCEPId = 2;  // identifies the source connection endpoint
                                    // (unique within the source IPC process)
  optional uint32 destinationCEPId = 3;  // identifies the destination
                                         // connection endpoint (unique within
                                         // the destination IPC process)
}

message Flow {  // Contains the information to setup a new flow
  required applicationProcessNamingInfo_t sourceNamingInfo =
      1;  // The naming information of the source application process
  required applicationProcessNamingInfo_t destinationNamingInfo =
      2;  // The naming information of the destination application process
  required uint64 sourcePortId =
      3;  // The port id allocated to this flow by the source IPC process
  optional uint64 destinationPortId =
      4;  // The port id allocated to this flow by the destination IPC process
  required uint64 sourceAddress =
      5;  // The address of the source IPC process for this flow
  optional uint64 destinationAddress =
      6;  // The address of the destination IPC process for this flow
  repeated connectionId_t connectionIds =
      7;  // The identifiers of all the connections that can be used to support
          // this flow during its lifetime
  optional uint32 currentConnectionIdIndex =
      8;  // Identifies the index of the current active connection in the flow
  optional uint32 state = 9;  //
  optional qosSpecification_t qosParameters =
      10;  // the QoS parameters specified by the application process that
           // requested this flow
  optional connectionPolicies_t connectionPolicies =
      11;  // the configuration for the policies and parameters of this EFCP
           // connection
  optional bytes accessControl = 12;  // ?
  optional uint32 maxCreateFlowRetries =
      13;  // Maximum number of retries to create the flow before giving up
  optional uint32 createFlowRetries = 14;  // The current number of retries
  optional uint32 hopCount =
      15;  // While the search rules that generate the
           // forwarding table should allow for a natural
           // termination condition, it seems wise to have
           // the means to enforce termination
}

message flowStateObject_t {  // Contains the information of a flow state object
  optional string name = 1;  // The name of the IPC Process
  optional string neighbor_name = 2;  // The name of the neighbor IPC Process
  optional uint32 cost = 3;           // The cost associated to the N-1 flow
  optional uint32 sequence_number =
      4;  // A sequence number to be able to discard old information
  optional bool state = 5;  // Tells if the N-1 flow is up or down
  optional uint32 age = 6;  // Age of this FSO (in seconds)
}

message flowStateObjectGroup_t {  // Contains the information of a flow service
  repeated flowStateObject_t flow_state_objects =
      1;  // A group of flow state objects
}

message neighbors_t {  // carries information about all the neighbors
  repeated neighbor_t neighbor = 1;
}

message neighbor_t {  // carries information about a neighbor
  optional string applicationProcessName = 1;
  optional string applicationProcessInstance = 2;
  optional uint64 address = 3;
  repeated string supportingDifs = 4;
}

message policyDescriptor_t {           // Describes a policy
  optional string policyName = 1;      // The name of the policy
  optional string policyImplName = 2;  // The name of the implementation of the
                                       // policy used in this DIF. Can be a
                                       // hierarchical name
  optional string version = 3;  // The version of the policy implementation
  repeated property_t policyParameters = 4;  // The paramters of the policy
}

message qosSpecification_t {  // The QoS parameters requested by an application
                              // for a certain flow
  optional string name = 1;   // The name of the QoS cube, if known
  optional uint32 qosid =
      2;  // The if of the QoS cube, if known (-1 = not known)
  optional uint64 averageBandwidth =
      3;  // in bytes/s, a value of 0 indicates 'don't care'
  optional uint64 averageSDUBandwidth =
      4;  // in bytes/s, a value of 0 indicates 'don't care'
  optional uint32 peakBandwidthDuration =
      5;  // in ms, a value of 0 indicates 'don't care'
  optional uint32 peakSDUBandwidthDuration =
      6;  // in ms, a value of 0 indicates 'don't care'
  optional double undetectedBitErrorRate =
      7;  // a value of 0 indicates 'don`t care'
  optional bool partialDelivery =
      8;  // indicates if partial delivery of SDUs is allowed or not
  optional bool order = 9;  // indicates if SDUs have to be delivered in order
  optional int32 maxAllowableGapSdu =
      10;  // indicates the maximum gap allowed in SDUs, a gap of N SDUs is
           // considered the same as all SDUs delivered. A value of -1 indicates
           // 'Any'
  optional uint32 delay = 11;   // in milliseconds, indicates the maximum delay
                                // allowed in this flow. A value of 0 indicates
                                // don't care
  optional uint32 jitter = 12;  // in milliseconds, indicates indicates the
                                // maximum jitter allowed in this flow. A value
                                // of 0 indicates don't care
  repeated property_t extraParameters = 13;  // the extra parameters specified
                                             // by the application process that
                                             // requested this flow
}
